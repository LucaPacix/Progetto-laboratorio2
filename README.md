# Progetto lab 24/25



## 1. Parsing del file name.basics.tsv
Il parsing del file **_name.basics.tsv_** viene effettuato tramite un ciclo **while** che legge una riga del file alla volta utilizzando la funzione **readLine()**, e termina al raggiungimento della fine del file. All'interno del ciclo, ogni riga viene suddivisa nei singoli campi mediante la funzione **.split("\t")**, in quanto i dati sono separati da tabulazioni (**\\t**). Successivamente, viene verificato che il terzo campo, corrispondente all’anno di nascita, sia definito, ovvero diverso da **"\N"**. In caso contrario, la riga viene ignorata e si passa all’iterazione successiva del ciclo.
A questo punto, viene effettuato uno **split(",")** sul quinto campo, che rappresenta le professioni associate alla persona, e si controlla, attraverso un ciclo **for**, che almeno una di esse corrisponda a **"actor"** o **"actress"**, utilizzando il metodo **.equals()** per il confronto. Se anche questa condizione fosse soddisfatta, i dati vengono salvati all’interno di una struttura dati **TreeMap**, in cui la chiave rappresenta il codice numerico dell’attore, ottenuto rimuovendo il prefisso **"nm"** dal primo campo tramite **.substring(2)** e convertito in intero mediante **Integer.parseInt()**.
Il valore associato è un oggetto di tipo **Attore** (definito dalla classe _Attore_) che conterrà le informazioni raccolte: codice, nome (preso dal secondo campo) e anno di nascita (dal terzo campo).Al termine del parsing si ottiene dunque una struttura **TreeMap<Integer, Attore>** ordinata per codice, in cui ogni attore è rappresentato da codice, nome e data di nascita.


## 2. Implementazione della coda FIFO nell'algoritmo BFS
L’implementazione della __coda FIFO__ nell’algoritmo __BFS__ si basa su una struttura dinamica __coda_FIFO__ che mantiene due puntatori, _inizio_ e _fine_, per gestire una __lista concatenata dinamica__ di nodi (_nodo_coda_), ognuno contenente il __codice intero di un attore__ e un __puntatore al nodo successivo__. La gestione della coda avviene tramite __allocazioni dinamiche__ con __malloc__ e __realloc__. La memoria viene sempre correttamente liberata con __free__, ad esempio tramite la funzione **FIFO_free**.  
La coda consente di inserire nuovi codici in fondo tramite la funzione **enqueue(coda, codice)** e di estrarre in testa con **dequeue(coda)**, garantendo così l’ordine FIFO necessario all’esplorazione della __BFS__.  Ogni elemento della coda memorizza soltanto il codice dell’attore da visitare, mentre informazioni aggiuntive, come i __padri dei nodi__, sono memorizzate separatamente in un albero binario di ricerca (ABR) che tiene traccia sia dei __nodi già visitati__ sia del __nodo padre__ di ciascun elemento (necessario per la __ricostruzione del cammino minimo__).  
La coda, inizializzata con **coda_init()**, assicura che gli attori vengano processati in ordine di scoperta, permettendo di visitare completamente tutti i vicini di un dato livello prima di passare al successivo.  L’inserimento di un vicino nella coda è condizionato dal fatto che il nodo non sia già stato visitato (cioè non presente nell’ABR), evitando cicli e visite ripetute.  


## 3. Ricostruzione del cammino minimo
Durante la ricerca del _cammino minimo_, una volta che il nodo di destinazione (_cod2_) è stato raggiunto tramite la BFS, viene avviata la procedura di ricostruzione del cammino. Per tenere traccia dei nodi visitati durante l’esplorazione, il programma utilizza un albero binario di ricerca (ABR), implementato tramite le funzioni **abr_insert**(nodo, codice, padre) e **abr_search**(nodo, codice), in cui ogni nodo memorizza il codice dell’attore visitato (in forma _shufflata_) e il **codice del padre**, ovvero il nodo da cui è stato scoperto. 
Quando la BFS termina con successo, viene creato un array dinamico che conterrà i nodi del cammino minimo in **ordine inverso**. La risalita del cammino avviene tramite un ciclo **while** che procede finché non si raggiunge il nodo iniziale. Durante questo ciclo, ad ogni iterazione, il padre del nodo corrente viene recuperato ricorsivamente tramite **get_padre**(radice, nodo), e il nodo viene aggiunto all’array dinamico. Si verifica continuamente se l’array ha raggiunto la sua _capacità massima_ e, in tal caso, viene esteso con **realloc**, raddoppiando la sua dimensione per garantire efficienza nella gestione della memoria.
Al termine della risalita, l’array contiene i nodi del cammino in ordine inverso quindi per stampare il cammino nel corretto ordine si percorre l’array al **contrario**. Per ogni codice nodo presente nell’array, si esegue una ricerca binaria **bsearch()** nell’array degli attori per recuperare le informazioni dettagliate (codice, nome, anno). Queste informazioni vengono quindi scritte sul file di output ottenendo quindi la stampa ordinata del cammino minimo con le informazioni appropriate.


## 4. Il thread gestore segnali comunica al programma principale di interrompere l'elaborazione
Una volta che il thread gestore segnali si sveglia dalla **sigwait**, valuta lo stato di due variabili condivise _fase pipe_ e _fase programma_ con l’uso di una mutex, per capire cosa deve fare. Dopo aver fatto i controlli per determinare il tipo di azione da eseguire, se il segnale di terminazione arriva quando la _fase pipe_ è ancora a 0, allora stampa il messaggio _**"Costruzione grafo in corso"**_ e torna in attesa. Nel caso in cui debba terminare il programma principale (_fase pipe_ diversa da 0), aggiorna semplicemente una variabile condivisa (_termina pipe_), sempre con l’uso della mutex, e termina. Il programma principale, durante la lettura della pipe, controllerà a ogni iterazione se la variabile _termina pipe_ è stata aggiornata e, in tal caso, termina immediatamente.


## 5. Come vengono memorizzate e gestite le partecipazioni degli attori
Per memorizzare le partecipazioni, il programma utilizza una struttura dati **HashMap<Integer, HashSet<Integer>>** chiamata _attfilm_, che associa a ogni codice attore un set contenente i codici dei film a cui ha partecipato. Durante la lettura del file _title.principals.tsv_, per ogni attore valido si aggiunge la chiave (codice attore) e il valore (HashSet), che viene poi mano a mano aggiornato con tutti i film a cui l’attore ha partecipato. 
Successivamente, per la scrittura del file _partecipazioni.txt_, il programma scorre tutti gli attori presenti nella mappa _attori_, verifica se l’attore è presente in _attfilm_, recupera una lista dall’HashSet dei film associati, ordina questa lista in ordine crescente e costruisce una riga contenente il codice dell’attore, il numero di film a cui ha partecipato e la lista dei codici film separati da tabulazioni.

